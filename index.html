<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Ice Lasso</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
<style>
body { margin:0; background:#8fd3ff; }
canvas { display:block; margin:0 auto; }
</style>
</head>
<body>

<script>
const config = {
  type: Phaser.CANVAS,
  width: window.innerWidth,
  height: window.innerHeight,
  physics: {
    default: 'arcade',
    arcade: { gravity: { y: 220 }, debug: false }
  },
  scene: { preload, create, update }
};

let iceGroup, catchZone, scoreText, score = 0, grabbed = null, rope;

new Phaser.Game(config);

function preload() {
  this.load.image('ice','https://upload.wikimedia.org/wikipedia/commons/3/3b/Ice_cube.png');
}

function create() {
  const w = this.scale.width;
  const h = this.scale.height;

  this.cameras.main.setBackgroundColor('#8fd3ff');

  scoreText = this.add.text(20,20,'Score: 0',{
    font:'24px Arial', fill:'#000'
  });

  // VISUAL CUP (graphics only)
  const cupGfx = this.add.graphics();
  cupGfx.lineStyle(6, 0x333333);
  cupGfx.strokeRect(w/2 - 150, h - 260, 300, 200);

  // INVISIBLE CATCH ZONE (this is the fix)
  catchZone = this.add.rectangle(
    w/2,
    h - 140,
    260,
    40,
    0x00ff00,
    0
  );
  this.physics.add.existing(catchZone, true);

  iceGroup = this.physics.add.group();

  this.time.addEvent({
    delay: 900,
    loop: true,
    callback: () => {
      const ice = iceGroup.create(
        Phaser.Math.Between(w/2 - 120, w/2 + 120),
        -50,
        'ice'
      );
      ice.setScale(0.45);
      ice.setBounce(0);
    }
  });

  rope = this.add.graphics();

  this.input.on('pointerdown', p => {
    iceGroup.children.iterate(ice => {
      if (!ice) return;
      if (Phaser.Math.Distance.Between(p.x,p.y,ice.x,ice.y) < 50) {
        grabbed = ice;
        ice.body.allowGravity = false;
      }
    });
  });

  this.input.on('pointerup', () => {
    if (grabbed) {
      grabbed.body.allowGravity = true;
      grabbed = null;
    }
  });

  // OVERLAP instead of collider (IMPORTANT)
  this.physics.add.overlap(iceGroup, catchZone, ice => {
    ice.destroy();
    score++;
    scoreText.setText('Score: ' + score);
  });
}

function update() {
  rope.clear();
  if (grabbed) {
    grabbed.setPosition(this.input.x, this.input.y);
    rope.lineStyle(4, 0x00ffff);
    rope.beginPath();
    rope.moveTo(this.input.x, this.input.y);
    rope.lineTo(this.input.x, this.input.y - 25);
    rope.strokePath();
  }
}
</script>

</body>
</html>
